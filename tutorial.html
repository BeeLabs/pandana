

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial &mdash; pandana 0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="pandana 0.1 documentation" href="index.html"/>
        <link rel="next" title="Network API" href="network.html"/>
        <link rel="prev" title="Getting Started" href="introduction.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> pandana</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#the-general-workflow">The General Workflow</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#create-the-network">Create the Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assign-variables-and-perform-computations-for-nearest-queries">Assign variables and perform computations for nearest queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assign-variables-and-perform-computations-for-aggregation-queries">Assign variables and perform computations for aggregation queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#display-the-results">Display the results</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="network.html">Network API</a></li>
<li class="toctree-l1"><a class="reference internal" href="futurework.html">Planned Improvements</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">pandana</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Tutorial</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/tutorial.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>At this point it is probably helpful to make concrete the topics discussed in
the introduction by giving code sample.  There is also an IPython Notebook
in the <tt class="docutils literal"><span class="pre">Pandana</span></tt> repo which gives the entire workflow,
but the discussion here will take things line-by-line with a sufficient
summary of the functionality.</p>
<p>Note that these code samples assume you have imported pandana as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pandana</span> <span class="kn">as</span> <span class="nn">pdna</span>
</pre></div>
</div>
<div class="section" id="create-the-network">
<h2>Create the Network<a class="headerlink" href="#create-the-network" title="Permalink to this headline">¶</a></h2>
<p>First create the network.  Although the API is incredibly simple,
this is likely to be the most difficult part of using Pandana.  In the future
we will leverage the import functionality of tools like <tt class="docutils literal"><span class="pre">geopandas</span></tt> to
directly access OpenStreetMap and networks via shapefiles,
but for now the initialization <a class="reference internal" href="network.html#pandana.network.Network.__init__" title="pandana.network.Network.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.__init__()</span></tt></a>
takes a small number of Pandas Series objects.</p>
<p>The network is comprised of a set of nodes and edges.  We store our nodes and
edges as two Pandas DataFrames in an HDFStore object.  We can access them as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">HDFStore</span><span class="p">(</span><span class="s">&#39;data/osm_bayarea.h5&#39;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">nodes</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">edges</span>
<span class="k">print</span> <span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span> <span class="n">edges</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The output of the above code shows:</p>
<div class="highlight-python"><div class="highlight"><pre>              x           y
8   629310.1250  4095536.75
9   629120.9375  4095816.75
10  628951.5625  4096090.50

[3 rows x 2 columns]

   from  to      weight
6     8   9  338.255005
7     9  10  322.532990
8    10  11  218.505997

[3 rows x 3 columns]
</pre></div>
</div>
<p>The data structure is very simple indeed.  Nodes have an index which is the
id of the node and an x-y position.  Much like <tt class="docutils literal"><span class="pre">shapely</span></tt>, <tt class="docutils literal"><span class="pre">Pandana</span></tt> is
agnostic to the  coordinate system.  Use your local coordinate system or
longitude then latitude - either one will work.  Edges are then ids (which
aren&#8217;t used) and
<tt class="docutils literal"><span class="pre">from</span></tt> node ids and <tt class="docutils literal"><span class="pre">to</span></tt> node_ids which should index directly to the node
DataFrame.  A <tt class="docutils literal"><span class="pre">weight</span></tt> column (or multiple weight columns) is (are) required
as the impedance for the network.  Here distance is used from OpenStreetMap
edges.</p>
<p>To create the network given the above DataFrames, simply call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">=</span><span class="n">pdna</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="s">&quot;from&quot;</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="s">&quot;to&quot;</span><span class="p">],</span>
                 <span class="n">edges</span><span class="p">[[</span><span class="s">&quot;weight&quot;</span><span class="p">]])</span>
</pre></div>
</div>
<p>It&#8217;s probably a good idea (though not strictly required) to precompute a
given horizon distance so that aggregations don&#8217;t perform the network queries
unnecessarily.  This is done by calling the following code,
where 3000 meters is used as the horizon distance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that a large amount of time is spent in the precomputations that take
place for these two lines of code.  On my MacBook, these two lines of code
take 4 seconds and 8.5 seconds respectively.</p>
<p><strong>I also have a 4-core cpu, so if your precomputation is much slower,
check the IPython Notebook output (on the console) for a statement that says</strong>
<tt class="docutils literal"><span class="pre">Generating</span> <span class="pre">contraction</span> <span class="pre">hierarchies</span> <span class="pre">with</span> <span class="pre">4</span> <span class="pre">threads.</span></tt> <strong>If your output says
1 instead of 4 you are running single threaded.  If you are running on
a multi-core cpu, there is probably a way to speed up the computation.</strong></p>
</div>
<div class="section" id="assign-variables-and-perform-computations-for-nearest-queries">
<h2>Assign variables and perform computations for nearest queries<a class="headerlink" href="#assign-variables-and-perform-computations-for-nearest-queries" title="Permalink to this headline">¶</a></h2>
<p>Now for the fun part.  Nearest queries are slightly easier, so let&#8217;s cover that
first.</p>
<p>First initialize the POI (point-of-interest) engine.  This is a bit
strange for Python programmers, but because this code wraps a C++ API,
you need to initialize the memory first.  This is not a strict requirement
though, and future versions might remedy this.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">.</span><span class="n">init_pois</span><span class="p">(</span><span class="n">num_categories</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">max_pois</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>This initializes one category, at a max distance of 2000 meters for up to the
10 nearest points-of-interest.</p>
<p>Here is a link to the docs: <a class="reference internal" href="network.html#pandana.network.Network.init_pois" title="pandana.network.Network.init_pois"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.init_pois()</span></tt></a></p>
<p>Next initialize the category:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">.</span><span class="n">set_pois</span><span class="p">(</span><span class="s">&quot;restaurants&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>This code initializes the &#8220;restaurants&#8221; category with the positions specified
by the x and y columns (which are Pandas Series).  Next perform the query:</p>
<p>Here is a link to the docs: <a class="reference internal" href="network.html#pandana.network.Network.set_pois" title="pandana.network.Network.set_pois"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.set_pois()</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">.</span><span class="n">nearest_pois</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="s">&quot;restaurants&quot;</span><span class="p">,</span> <span class="n">num_pois</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>This searches for the 10 nearest restaurants and is exactly the query that is
displayed in the introduction.  This returns a DataFrame with the number of
columns equal to the number of POIs that are requested. For instance,
a describe of the output DataFrame look like this (note that the query
executed in half a second:</p>
<div class="highlight-python"><div class="highlight"><pre>CPU times: user 1.37 s, sys: 11 ms, total: 1.38 s
Wall time: 498 ms
                  1              2              3              4   \
count  226060.000000  226060.000000  226060.000000  226060.000000
mean     1542.487481    1676.578324    1746.392002    1794.982571
std       629.581983     543.853257     485.754919     440.356407
min         0.000000       0.000000       0.000000       0.000000
25%      1063.236542    1473.924011    1775.853271    2000.000000
50%      2000.000000    2000.000000    2000.000000    2000.000000
75%      2000.000000    2000.000000    2000.000000    2000.000000
max      2000.000000    2000.000000    2000.000000    2000.000000

                  5              6              7              8   \
count  226060.000000  226060.000000  226060.000000  226060.000000
mean     1825.214545    1846.061683    1864.423958    1879.123914
std       407.388660     380.878320     353.350067     330.835422
min         0.000000       0.000000       0.000000       0.000000
25%      2000.000000    2000.000000    2000.000000    2000.000000
50%      2000.000000    2000.000000    2000.000000    2000.000000
75%      2000.000000    2000.000000    2000.000000    2000.000000
max      2000.000000    2000.000000    2000.000000    2000.000000

                  9              10
count  226060.000000  226060.000000
mean     1893.909935    1908.403787
std       306.340819     283.554353
min         0.000000      56.143002
25%      2000.000000    2000.000000
50%      2000.000000    2000.000000
75%      2000.000000    2000.000000
max      2000.000000    2000.000000

[8 rows x 10 columns]
</pre></div>
</div>
<p>Here is a link to the docs: <a class="reference internal" href="network.html#pandana.network.Network.nearest_pois" title="pandana.network.Network.nearest_pois"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.nearest_pois()</span></tt></a></p>
</div>
<div class="section" id="assign-variables-and-perform-computations-for-aggregation-queries">
<h2>Assign variables and perform computations for aggregation queries<a class="headerlink" href="#assign-variables-and-perform-computations-for-aggregation-queries" title="Permalink to this headline">¶</a></h2>
<p>Performing a general network aggregation isn&#8217;t much harder.  In this case,
it is assumed that DataFrames are much larger and that queries have
a lot more variety.</p>
<p>For this reason, the workflow is typically to map the variables x and y to
node_ids (which can then be cached or written to disk at a later date) and
to call <tt class="docutils literal"><span class="pre">set</span></tt> for each data column, potentially several times.  For instance,
if you have a DataFrame of buildings with x and y coordinates,
you can use <tt class="docutils literal"><span class="pre">get_node_ids</span></tt> to set node_ids as an attribute on the
buildings table and then <tt class="docutils literal"><span class="pre">set</span></tt> can be called many times with all the
attributes of the buildings table and their associated column names.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">buildings</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">buildings</span><span class="o">.</span><span class="n">y</span>
<span class="n">buildings</span><span class="p">[</span><span class="s">&quot;node_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">get_node_ids</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">buildings</span><span class="o">.</span><span class="n">square_footage</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;square_footage&quot;</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">buildings</span><span class="o">.</span><span class="n">residential_units</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s">&quot;residential_units&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is a link to the docs: <a class="reference internal" href="network.html#pandana.network.Network.get_node_ids" title="pandana.network.Network.get_node_ids"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.get_node_ids()</span></tt></a>
and <a class="reference internal" href="network.html#pandana.network.Network.set" title="pandana.network.Network.set"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.set()</span></tt></a></p>
<p>Once the variables have been assigned to the network, the user can query the
network repeatedly with different parameters.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="s">&quot;linear&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;square_footage&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="s">&quot;linear&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;square_footage&quot;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="s">&quot;linear&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;square_footage&quot;</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="s">&quot;linear&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;square_footage&quot;</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;ave&quot;</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="s">&quot;flat&quot;</span><span class="p">,</span>
                  <span class="n">name</span><span class="o">=</span><span class="s">&quot;residential_units&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is a link to the docs: <a class="reference internal" href="network.html#pandana.network.Network.aggregate" title="pandana.network.Network.aggregate"><tt class="xref py py-meth docutils literal"><span class="pre">pandana.network.Network.aggregate()</span></tt></a></p>
<p>Note that if networks have been indexed and precomputed,
the aggregations should take less than a second up to a distance of roughly
three kilometers for a network with a few hundred thousand nodes.</p>
</div>
<div class="section" id="display-the-results">
<h2>Display the results<a class="headerlink" href="#display-the-results" title="Permalink to this headline">¶</a></h2>
<p>An experimental feature for displaying the points of the node_ids and their
associated computed values using matplotlib (so that the entire workflow can
happen in the notebook) is also available.</p>
<p>Note that these have a bounding box for reducing the display window.
Although the underlying library is computing values for all nodes in the
region, it is extremely difficult to visualize this much data using
matplotlib.  The GeoCanvas tool by Synthicity is expressly designed to join
indicators at the node level to shapes of parcels and produces a much more
professional output map.  For quick interactive checking of results,
the bounding box can be used to reduce the number of points that are shown,
and sample code and images are included below</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">122.539365</span><span class="p">,</span><span class="mf">37.693047</span><span class="p">,</span><span class="o">-</span><span class="mf">122.347698</span><span class="p">,</span><span class="mf">37.816069</span><span class="p">]</span>
<span class="n">net</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s">&quot;diverging&quot;</span><span class="p">,</span>
         <span class="n">color</span><span class="o">=</span><span class="s">&quot;BrBG&quot;</span><span class="p">,</span> <span class="n">log_scale</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/500metersum.png" src="_images/500metersum.png" />
<div class="highlight-python"><div class="highlight"><pre><span class="n">net</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s">&quot;diverging&quot;</span><span class="p">,</span>
         <span class="n">color</span><span class="o">=</span><span class="s">&quot;BrBG&quot;</span><span class="p">,</span> <span class="n">log_scale</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/2000metersum.png" src="_images/2000metersum.png" />
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="network.html" class="btn btn-neutral float-right" title="Network API"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral" title="Getting Started"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Synthicity.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>