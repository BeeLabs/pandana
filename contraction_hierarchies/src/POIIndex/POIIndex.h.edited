/*
 open source routing machine
 Copyright (C) Dennis Luxen, others 2010
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU AFFERO General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 or see http://www.gnu.org/licenses/agpl.txt.
 */
#ifndef POIINDEX_H_INCLUDED
#define POIINDEX_H_INCLUDED

#include <vector>

#include <boost/shared_ptr.hpp>
#include <boost/foreach.hpp>
#include <google/dense_hash_map>

#include "../BasicDefinitions.h"
#include "../DataStructures/BinaryHeap.h"

namespace CH {
    struct BucketEntry {
        NodeID node;
        EdgeWeight distance;
        BucketEntry() : node(UINT_MAX), distance(UINT_MAX) {}
        BucketEntry(NodeID n, EdgeWeight d) : node(n), distance(d) {}
        bool operator<(const BucketEntry & other) const {
            return distance < other.distance;
        }
    };
    
    typedef vector<BucketEntry> Bucket;
    typedef google::dense_hash_map<NodeID, Bucket> BucketIndex;
    
    //No need to store anything in the Heap for an encountered node besides its distance
    struct _POIHeapData {
        _POIHeapData(NodeID p) : parent(p) {} 
        NodeID parent;
    };
    typedef BinaryHeap<NodeID, NodeID, EdgeWeight, _POIHeapData, ArrayStorage<NodeID, NodeID> > POIHeap;
    
    template<typename QueryGraphT>
    class POIIndex {
    public:
        POIIndex(QueryGraphT * _graph, unsigned _maxNumberOfPOIsInBucket, unsigned _maxDistanceToConsider) :
        graph(_graph), maxNumberOfPOIsInBucket(_maxNumberOfPOIsInBucket), maxDistanceToConsider(_maxDistanceToConsider),
        numberOfThreads(1) {
            Initialize();
        }
        
        POIIndex(QueryGraphT * _graph, unsigned _maxDistanceToConsider, unsigned _maxNumberOfPOIsInBucket, unsigned _numberOfThreads) :
        graph(_graph), maxNumberOfPOIsInBucket(_maxNumberOfPOIsInBucket), maxDistanceToConsider(_maxDistanceToConsider),
        numberOfThreads(_numberOfThreads) {
            Initialize();
        }
        
        ~POIIndex() {
            bucketIndex.clear();
        }
        
        void addPOIToIndex(const NodeID node){
            CHASSERT(node < graph->GetNumberOfNodes(), "Node ID of POI is out of bounds");
<<<<<<< .mine
            //INFO("Inserting POI at node " << node << " into graph of size " << graph->GetNumberOfNodes());
=======
>>>>>>> .r10063
            additionHeap->Clear();
            CHASSERT(additionHeap->Size() == 0, "AdditionHeap not empty");
            //explore search space from node v
            additionHeap->Insert(node, 0, node);
            CHASSERT(additionHeap->Size() == 1, "AdditionHeap not empty");
            //For each encountered node u of the backward search space
            while(additionHeap->Size() > 0) {
                const NodeID currentNode = additionHeap->DeleteMin();
                const unsigned toDistance = additionHeap->GetKey( currentNode );
<<<<<<< .mine
                //INFO("Fetched node " << currentNode << " with distance " << toDistance << " from heap");
=======
>>>>>>> .r10063
                if(toDistance > maxDistanceToConsider)
                    return;
                //Add venue to bucket of u
                Bucket & bucket = bucketIndex[currentNode];
                bucket.push_back(BucketEntry(currentNode, toDistance));
                
                //sort bucket by distance
                std::sort(bucket.begin(), bucket.end());
                
                //if bucket size > max then delete last one
                if(bucket.size() > maxNumberOfPOIsInBucket)
                    bucket.resize(maxNumberOfPOIsInBucket);
                
                //add further edges from backward search space
                for ( typename QueryGraphT::EdgeIterator edge = graph->BeginEdges( currentNode ); edge < graph->EndEdges(currentNode); ++edge ) {
                    const NodeID to = graph->GetTarget(edge);
<<<<<<< .mine
                    //INFO("Relaxing edge (" << currentNode << "," << to << ")");
=======
>>>>>>> .r10063
                    CHASSERT( to < graph->GetNumberOfNodes(), "Edge leads to out of bounds target node ID. Graph corrupted");
                    const EdgeWeight edgeDistance = graph->GetEdgeData(edge).distance;
                    
                    if(graph->GetEdgeData(edge).backward) {
                        CHASSERT( edgeDistance > 0, "Edge (" << currentNode << "," << to << ") has length " << edgeDistance );
                        
                        //New Node discovered -> Add to Heap + Node Info Storage
                        if ( !additionHeap->WasInserted( to ) ) {
                            additionHeap->Insert( to, toDistance, node );
                        }
                        //Found a shorter Path -> Update distance
                        else if ( toDistance < additionHeap->GetKey( to ) ) {
                            additionHeap->DecreaseKey( to, toDistance );
                        }
                    }
                }
            }
        }
        
        //Also, functions for subset of parameters
        void getNearestPOIs(NodeID node, std::vector<BucketEntry>& resultingVenues){
            getNearestPOIs(node, resultingVenues, maxDistanceToConsider, maxNumberOfPOIsInBucket);
        }

        void getNearestPOIs(NodeID node, std::vector<BucketEntry>& resultingVenues, unsigned threadID){
            getNearestPOIs(node, resultingVenues, maxDistanceToConsider, maxNumberOfPOIsInBucket, threadID);
        }
        
        void getNearestPOIsWithUpperBoundOnDistance(NodeID node, unsigned maxQueryDistanceToConsider, std::vector<BucketEntry>& resultingVenues){
            getNearestPOIs(node, resultingVenues, maxQueryDistanceToConsider, maxNumberOfPOIsInBucket);
        }
        
        void getNearestPOIsWithUpperBoundOnLocations(NodeID node, unsigned maxQueryNumberOfLocationsToConsider, std::vector<BucketEntry>& resultingVenues){
            getNearestPOIs(node, resultingVenues, maxDistanceToConsider, maxQueryNumberOfLocationsToConsider);
        }
        
        void getNearestPOIs(NodeID node, std::vector<BucketEntry>& resultingVenues, unsigned _maxDistanceToConsider, unsigned _maxNumberOfPOIsInBucket, unsigned threadID = 0){
<<<<<<< .mine
            POIHeap queryHeap(graph->GetNumberOfNodes());
            POIHeap resultHeap(graph->GetNumberOfNodes());
            //INFO("Search for nearest venues close to node " << node);
=======
            //INFO("Search for nearest venues close to node " << node);
            //INFO("_maxDistanceToConsider: " << _maxDistanceToConsider << ", _maxNumberOfPOIsInBucket: " << _maxNumberOfPOIsInBucket);
>>>>>>> .r10063
            CHASSERT(0 == resultingVenues.size(), "Resulting vector of getNearestQuery is not empty");
            CHASSERT(_maxDistanceToConsider <= maxDistanceToConsider, "Maximum distance to POIs must not be larger in query than during preprocessing");
            CHASSERT(_maxNumberOfPOIsInBucket <= maxNumberOfPOIsInBucket, "Maximumum number of POIs must not be larger in query than during preprocessing");
            
            threadDataArray[threadID]->resultHeap.Clear();
            
            threadDataArray[threadID]->queryHeap.Clear();
            threadDataArray[threadID]->queryHeap.Insert(node, 0, node);
            
            //explore search space from node v
            while(threadDataArray[threadID]->queryHeap.Size() > 0) {
                //for each encountered node in forward search space
                const NodeID node = threadDataArray[threadID]->queryHeap.DeleteMin();
                const unsigned toDistance = threadDataArray[threadID]->queryHeap.GetKey(node);
                //INFO("Looking at node " << node << " with distance " << toDistance);
                
                //continue only if we are not out of distance limits
                if(toDistance > _maxDistanceToConsider) {
                    //INFO("Reached maximum distance");
                    break;
                }
                
                //check if there is a bucket entry at that node
                if(bucketIndex.find(node) != bucketIndex.end()) {
                    Bucket & bucket = bucketIndex[node];
                    //INFO("Found bucket of size " << bucket.size());
                    
                    //put all venues at bucket into result heap that are closer than maximum distance
                    BOOST_FOREACH(BucketEntry b, bucket){
                        //Do we already know this guy?
                        if(threadDataArray[threadID]->resultHeap.WasInserted(b.node)){
                            //Yes, lets check if we encountered it with a smaller distance.
                            if(threadDataArray[threadID]->resultHeap.GetKey(b.node) > toDistance + b.distance){
                                threadDataArray[threadID]->resultHeap.DecreaseKey(b.node, (toDistance + b.distance));
                            }
                        }else {
                            //No, so lets insert the entry
                            threadDataArray[threadID]->resultHeap.Insert(b.node, toDistance + b.distance, b.node); 
                            
                            //INFO("Adding node " << b.node << " with distance " << (toDistance + b.distance) << " to result");
                        }
                    }
                    //INFO("Resulting heap has " << threadDataArray[threadID]->resultHeap.Size() << "/" << _maxNumberOfPOIsInBucket << " entries");
                }
            }
            //put the k smallest elements into results vector
            for(unsigned i = 0; i < _maxNumberOfPOIsInBucket && threadDataArray[threadID]->resultHeap.Size() > 0; ++i){
                const NodeID node = threadDataArray[threadID]->resultHeap.DeleteMin();
                const EdgeWeight distance = threadDataArray[threadID]->resultHeap.GetKey(node);
                //INFO("Fixed POI at node " << node << " with distance " << distance);
                resultingVenues.push_back(BucketEntry(node, distance));
            }
            //INFO("Returning " << resultingVenues.size() << " POIs from search");
        }
                
    private:
        /** Inits the internal data structures */
        void Initialize() {
            additionHeap.reset(new POIHeap(graph->GetNumberOfNodes()));
            bucketIndex.set_empty_key(UINT_MAX);
            CHASSERT(numberOfThreads > 0, "Number of threads must be a non-negative integer");
            for(unsigned i = 0; i < numberOfThreads; ++i)
                threadDataArray.push_back(boost::shared_ptr<_ThreadData>(new _ThreadData(graph->GetNumberOfNodes()) ) );
        }
        
        struct _ThreadData {
            _ThreadData() {
                assert(false);
            }
            _ThreadData(unsigned size) :queryHeap(size), resultHeap(size) { }
            POIHeap queryHeap;
            POIHeap resultHeap;
        };
        QueryGraphT * graph;
        unsigned maxNumberOfPOIsInBucket;
        unsigned maxDistanceToConsider;
        unsigned numberOfThreads;
        BucketIndex bucketIndex;
        boost::shared_ptr<POIHeap> additionHeap;
        std::vector<boost::shared_ptr<_ThreadData> > threadDataArray;
    };
}

#endif //POIINDEX_H_INCLUDED
